<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Coupling &amp; Cohesion</title>
<meta name="generator" content="Org Mode" />
<style>
  #content { max-width: 60em; margin: auto; }
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #e6e6e6;
    border-radius: 3px;
    background-color: #f2f2f2;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: auto;
  }
  pre.src:before {
    display: none;
    position: absolute;
    top: -8px;
    right: 12px;
    padding: 3px;
    color: #555;
    background-color: #f2f2f299;
  }
  pre.src:hover:before { display: inline; margin-top: 14px;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-authinfo::before { content: 'Authinfo'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .equation-container {
    display: table;
    text-align: center;
    width: 100%;
  }
  .equation {
    vertical-align: middle;
  }
  .equation-label {
    display: table-cell;
    text-align: right;
    vertical-align: middle;
  }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { width: 90%; }
</style>
<link rel="stylesheet" type="text/css" href="./css/local.css" />
</head>
<body>
<div id="content" class="content">
<h1 class="title">Coupling &amp; Cohesion</h1>

<div id="outline-container-orge099089" class="outline-2">
<h2 id="orge099089" class="hidden">Coupling &amp; Cohesion</h2>
<div class="outline-text-2" id="text-orge099089">
<div class="NOTES" id="org6ecb9a1">
<p>
В основе разработки ПО лежит управление сложностью. Добавляя новую функциональность в систему мы неизбежно увеличиваем ее сложность. Но правильные подходы к разработке и хорошо построенная архитектура может замедлить рост сложности.
Проблема только в том, что никто не знает как она должна выглядеть, эта хорошо построенная архитектура.
Но существуют метрики, которые помогают нам оценить архитектуру, о двух таких метриках я бы и хотел поговорить
</p>

</div>

<ul class="org-ul">
<li><b>Coupling (Связанность)</b> <br />
насколько сильно связаны друг с другом отдельные модули.</li>
<li><b>Cohesion (Сочетаемость)</b> <br />
насколько сильны связи внутри модуля.</li>
</ul>

<div class="NOTES" id="org3f7ac57">
<p>
Используя этим метрики можно анализировать не только архитектуру отдельного приложения, но и целых систем, состоящих из многих сервисов, поэтому в определении используется слово модуль.
Сами термины были введены Ларри Константином в конце 60-ых годов, позже в 1974 детально описаны в его книге Structured Design.
Считается, что хорошо спроектированная система обладает низкой связанностью и высокой сочетаемостью (Low coupling &amp; High cohesion).
</p>

</div>

<div id="org2e2e116" class="figure">
<p><img src="./img/CouplingVsCohesion.png" alt="CouplingVsCohesion.png" width="60%" />
</p>
</div>
</div>
</div>

<div id="outline-container-org695c6ec" class="outline-2">
<h2 id="org695c6ec">Coupling</h2>
<div class="outline-text-2" id="text-org695c6ec">
<div class="NOTES" id="org4b002be">
<p>
Сначала поговорим о связанности, метрике, которая показывает насколько сильна связь между двумя модулями. Чем сильнее связанны модули, чем больше самих связей между ними, тем вероятнее, что изменения в одном из них затронут остальные. Высокий уровень связанности усложняет рефакторнинг и доработку кода.
Рассмотрим какие бывают типы связей в порядке от самых сильных к слабым.
</p>

</div>
</div>
<div id="outline-container-org932f4d9" class="outline-3">
<h3 id="org932f4d9">Content Coupling</h3>
<div class="outline-text-3" id="text-org932f4d9">
<p>
Возникает, когда один модуль полагается на внутренние особенности реализации другого модуля.
</p>

<div class="NOTES" id="org0dbc4bf">
<p>
Связанность по содержимому является нарушением принципа инкапсуляции. Изменение имплементации одного модуля приведет к переписыванию другого.
Пример content coupling:
</p>

</div>

<div class="org-src-container">
<pre class="src src-java"><span style="color: #51afef;">public</span> <span style="color: #51afef;">class</span> <span style="color: #ECBE7B;">ShopService</span> <span style="color: #51afef;">{</span>

  <span style="color: #51afef;">public</span> <span style="color: #ECBE7B;">void</span> <span style="color: #c678dd;">addNewItem</span><span style="color: #c678dd;">(</span><span style="color: #ECBE7B;">Order</span> <span style="color: #dcaeea;">order</span>, <span style="color: #ECBE7B;">OrderItem</span> <span style="color: #dcaeea;">newItem</span><span style="color: #c678dd;">)</span> <span style="color: #c678dd;">{</span>
    order.getItems<span style="color: #98be65;">()</span>.add<span style="color: #98be65;">(</span>newItem<span style="color: #98be65;">)</span>;
    order.setSum<span style="color: #98be65;">(</span>order.getSum<span style="color: #a9a1e1;">()</span> + newItem.getPrice<span style="color: #a9a1e1;">()</span><span style="color: #98be65;">)</span>;
  <span style="color: #c678dd;">}</span>
<span style="color: #51afef;">}</span>
</pre>
</div>

<div class="NOTES" id="orgeee4998">
<p>
<b>Проблемы:</b>
</p>
<ul class="org-ul">
<li>Нарушена инкапсуляция. Класс Order не отвечает за свое состояние.</li>
<li>Сложно поддерживать. При изменении структуры Order необходимо поменять все места использования.</li>
</ul>

<p>
Этот код зависит от внутреннего строения класса <code>Order</code>. Если мы захотим поменять тип списка товаров <code>items</code> внутри <code>Order</code> или, например, сумму в виде числа заменить классом <code>Money</code>, то это приведет к рефакторингу функции <code>addNewItem</code> и всех остальных мест, где используется класс <code>Order</code>.
Так же в этой функции мы делаем предположение о связях между полями внутри самого класса <code>Order</code>, что при добавлении нового продукта необходимо добавить его стоимость к сумме.
Поскольку метод <code>setSum</code> публичный, то его можно вызвать из любого места приложения, и значит в каждом из этих мест мы должны проверять, что правильно рассчитали сумму. Если же алгоритм расчета суммы меняется - все становится еще хуже.
</p>

<p>
Вместо этого модули должны обращаться друг к другу только через интерфейс. Уберем всю логику по добавлению нового товара в класс <code>Order</code>, чтобы избавится от content coupling:
</p>

</div>

<div class="org-src-container">
<pre class="src src-java"><span style="color: #51afef;">public</span> <span style="color: #51afef;">class</span> <span style="color: #ECBE7B;">ShopService</span> <span style="color: #51afef;">{</span>

  <span style="color: #51afef;">public</span> <span style="color: #ECBE7B;">void</span> <span style="color: #c678dd;">addNewItem</span><span style="color: #c678dd;">(</span><span style="color: #ECBE7B;">Order</span> <span style="color: #dcaeea;">order</span>, <span style="color: #ECBE7B;">OrderItem</span> <span style="color: #dcaeea;">newItem</span><span style="color: #c678dd;">)</span> <span style="color: #c678dd;">{</span>
    order.addItem<span style="color: #98be65;">(</span>newItem<span style="color: #98be65;">)</span>;
  <span style="color: #c678dd;">}</span>
<span style="color: #51afef;">}</span>
</pre>
</div>
<div class="NOTES" id="orgbd8764d">
<p>
Теперь класс <code>ShopService</code> не зависит от внутреннего строения класса <code>Order</code>. Класс <code>Order</code> проще тестировать и переиспользовать в других местах, так как вся логика инкапсулирована в методе <code>addItem</code> и сам класс заботится о выполнении всех бизнес правил, описывающих его возможные состояния. Меняя внутреннюю структуру класса <code>Order</code> нам не придется переписывать код, который использует этот класс.
Можно сказать, что при данном рефакторинге мы последовали закону Деметры, или принципу наименьшего знания, как его иногда называют.
</p>

</div>
</div>

<div id="outline-container-orge433031" class="outline-4">
<h4 id="orge433031">Law of Demeter</h4>
<div class="outline-text-4" id="text-orge433031">
<p>
Объект должен иметь как можно меньше представления о структуре и свойствах другого объекта.
</p>
<div class="NOTES" id="org441fb81">
<p>
Закон Деметры был сформулирован в 1987 году, он служит для уменьшения связанность между компонентами системы. В языках где для доступа к вложенным структурам используется точка можно упростить его до правила одной точки.
</p>

</div>

<div id="orgb3050e8" class="figure">
<p><img src="./img/demeter-law.png" alt="demeter-law.png" width="60%" />
</p>
</div>
</div>
</div>
</div>

<div id="outline-container-orga4f5988" class="outline-3">
<h3 id="orga4f5988">Common Coupling</h3>
<div class="outline-text-3" id="text-orga4f5988">
<p>
Возникает между модулями, когда они работают с общими данными читая и изменяя их.
</p>
<div class="NOTES" id="org1eb43ed">
<p>
<b>Проблемы:</b>
</p>
<ul class="org-ul">
<li>Сложно понимать. Нет единого места, отвечающего за данные. Данные могут стать неконсистентными.</li>
<li>Сложно поддерживать. Тяжело определить кто в этот раз поменял общие данные.</li>
</ul>

<p>
Например, два класса модифицируют одну глобальную переменную или  два сервиса пишут в одну и ту же таблицу в БД.
При наличие common coupling становится сложно проследить, почему значение разделяемого ресурса стало именно таким, так как оно может поменяться в любой момент и из разных мест. Это может привести к трудно отлавливаемым ошибкам. Также, при внесении изменений в структуру разделяемого ресурса, придется менять все работающие с ним модули.
Модули работающие с глобальными переменными практически не пригодны к переиспользованию.
</p>

<p>
Важно обратить внимание, что проблемы от такого вида связанности возникают в случае, если оба модуля ИЗМЕНЯЮТ общие данные. Если же в качестве общих данных глобальный набор констант или меняет общий ресурс один модуль, а остальные только читают, то такой вид связанности обычно менее болезненный.
</p>

<p>
На практике такой вид связанности возникает не часто, так как в сознание разработчиков на старте карьеры закладывают убеждение, что глобальные переменные - это плохо, а БД у каждого микросервиса должна быть своя.
</p>

</div>


<div id="org7a94329" class="figure">
<p><img src="./img/common-coupling-ex1.png" alt="common-coupling-ex1.png" width="30%" />
</p>
</div>
</div>
</div>

<div id="outline-container-orge5c361f" class="outline-3">
<h3 id="orge5c361f">Control Coupling</h3>
<div class="outline-text-3" id="text-orge5c361f">
<p>
Возникает, когда один модуль управляет поведением другого, через передачу каких-то данных или флагов управления.
</p>

<div class="org-src-container">
<pre class="src src-java"><span style="color: #51afef;">class</span> <span style="color: #ECBE7B;">OrderService</span> <span style="color: #51afef;">{</span>
  <span style="color: #51afef;">private</span> <span style="color: #ECBE7B;">ReportService</span> <span style="color: #dcaeea;">reportService</span>;

  <span style="color: #51afef;">public</span> <span style="color: #ECBE7B;">void</span> <span style="color: #c678dd;">placeOrder</span><span style="color: #c678dd;">()</span> <span style="color: #c678dd;">{</span>
    <span style="color: #5B6268;">// </span><span style="color: #5B6268;">...</span>
    reportService.generate<span style="color: #98be65;">(</span>order, <span style="color: #a9a1e1;">ReportType</span>.PDF<span style="color: #98be65;">)</span>;
  <span style="color: #c678dd;">}</span>
<span style="color: #51afef;">}</span>
</pre>
</div>

<div class="org-src-container">
<pre class="src src-java"><span style="color: #51afef;">class</span> <span style="color: #ECBE7B;">ReportService</span> <span style="color: #51afef;">{</span>

  <span style="color: #51afef;">public</span> <span style="color: #ECBE7B;">void</span> <span style="color: #c678dd;">generate</span><span style="color: #c678dd;">(</span><span style="color: #ECBE7B;">Order</span> <span style="color: #dcaeea;">data</span>, <span style="color: #ECBE7B;">ReportType</span> <span style="color: #dcaeea;">type</span><span style="color: #c678dd;">)</span> <span style="color: #c678dd;">{</span>
    <span style="color: #51afef;">switch</span> <span style="color: #98be65;">(</span>type<span style="color: #98be65;">)</span> <span style="color: #98be65;">{</span>
        <span style="color: #51afef;">case</span> XML:
            buildXmlReport<span style="color: #a9a1e1;">(</span>data<span style="color: #a9a1e1;">)</span>;
            <span style="color: #51afef;">break</span>;
        <span style="color: #51afef;">case</span> PDF:
            buildPdfReport<span style="color: #a9a1e1;">(</span>data<span style="color: #a9a1e1;">)</span>;
            <span style="color: #51afef;">break</span>;
    <span style="color: #98be65;">}</span>
  <span style="color: #c678dd;">}</span>

  <span style="color: #51afef;">private</span> <span style="color: #ECBE7B;">void</span> <span style="color: #c678dd;">buildXmlReport</span><span style="color: #c678dd;">()</span> <span style="color: #c678dd;">{</span> ... <span style="color: #c678dd;">}</span>
  <span style="color: #51afef;">private</span> <span style="color: #ECBE7B;">void</span> <span style="color: #c678dd;">buildPdfReport</span><span style="color: #c678dd;">()</span> <span style="color: #c678dd;">{</span> ... <span style="color: #c678dd;">}</span>
<span style="color: #51afef;">}</span>
</pre>
</div>

<div class="NOTES" id="org9a02b80">
<p>
<b>Проблемы:</b>
</p>
<ul class="org-ul">
<li>Сложно переиспользовать. Класс <code>ReportService</code> пологается на внешний код для принятия решения</li>
<li>Сложно поддерживать. При добавлении новых типов отчетов необходимо дорабатывать не только <code>ReportSrevice</code>, но и <code>OrderService</code></li>
</ul>

<p>
Проблема в том, что какой-то внешний по отношению к <code>ReportService</code> модуль управляет его поведением, это говорит о нарушении инкапсуляции, получается, что в самом модуле для этого нехватает логики. Это приводит к тому, что нельзя просто переиспользовать класс <code>ReportService</code> не копируя недостоющую логику по определению желаемого типа отчета.
</p>

<p>
<code>OrderService</code> в этой ситуации выступает как координатор, он говорит что необходимо сделать и какой результат он ожидает.
В ООП же объекты должны сами принимать решения, и содержать всю необходимую для выполнения задачи логику. Control coupling в этом примере можно убрать используя паттерн стратегия. При этом каждый алгоритм из <code>ReportService</code> мы переносим в отдельный класс. Либо инкапсулируя всю логику по определению типа отчета в класс <code>ReportService</code>.
</p>

</div>

<div class="org-src-container">
<pre class="src src-java"><span style="color: #51afef;">class</span> <span style="color: #ECBE7B;">OrderService</span> <span style="color: #51afef;">{</span>
  <span style="color: #51afef;">private</span> <span style="color: #ECBE7B;">ReportService</span> <span style="color: #dcaeea;">reportService</span>;

  <span style="color: #51afef;">public</span> <span style="color: #ECBE7B;">void</span> <span style="color: #c678dd;">placeOrder</span><span style="color: #c678dd;">()</span> <span style="color: #c678dd;">{</span>
    <span style="color: #5B6268;">// </span><span style="color: #5B6268;">...</span>
    reportService.generate<span style="color: #98be65;">(</span>order<span style="color: #98be65;">)</span>;
  <span style="color: #c678dd;">}</span>
<span style="color: #51afef;">}</span>
</pre>
</div>

<div class="org-src-container">
<pre class="src src-java"><span style="color: #51afef;">public</span> <span style="color: #51afef;">interface</span> <span style="color: #ECBE7B;">ReportService</span> <span style="color: #51afef;">{</span>
    <span style="color: #ECBE7B;">void</span> <span style="color: #c678dd;">generate</span><span style="color: #c678dd;">(</span><span style="color: #ECBE7B;">Order</span> <span style="color: #dcaeea;">order</span><span style="color: #c678dd;">)</span>;
<span style="color: #51afef;">}</span>

<span style="color: #51afef;">public</span> <span style="color: #51afef;">class</span> <span style="color: #ECBE7B;">XmlReportBuilder</span> <span style="color: #51afef;">implements</span> <span style="color: #ECBE7B;">ReportService</span> <span style="color: #51afef;">{</span>  <span style="color: #51afef;">}</span>
<span style="color: #51afef;">public</span> <span style="color: #51afef;">class</span> <span style="color: #ECBE7B;">PdfReportBuilder</span> <span style="color: #51afef;">implements</span> <span style="color: #ECBE7B;">ReportService</span> <span style="color: #51afef;">{</span>  <span style="color: #51afef;">}</span>
</pre>
</div>

<div class="NOTES" id="orgeb65637">
<p>
Таким образом мы изолировали каждый алгоритм в отдельном классе, что гораздо удобнее с точки зрения тестирования и понимания кода. Добавление новых типов отчетов не потребует изменения класса <code>OrderService</code>, что являлось для нас главной целью при снижении связанности.
</p>

</div>

<div class="NOTES" id="org5cb84a0">
<p>
Как один из примеров control coupling часто встречаются методы, принимающие <code>boolean</code> флаги, которые определяют их поведение.
Помимо связанности тут еще присутствует проблема <code>boolean blindness</code>. Догадаться что означает этот <code>true</code> без чтения кода метода абсолютно невозможно. В данном случае можно просто разделить метод на два:
</p>

</div>


<div id="orgbc62e7f" class="figure">
<p><img src="./img/control-coupling.png" alt="control-coupling.png" width="60%" />
</p>
</div>
</div>
</div>

<div id="outline-container-org5d5c4be" class="outline-3">
<h3 id="org5d5c4be">Stamp Coupling</h3>
<div class="outline-text-3" id="text-org5d5c4be">
<p>
Возникает, когда модули обмениваются друг с другом данными через структуру, но при этом из этой структуры модули используют не все поля.
</p>
<div class="org-src-container">
<pre class="src src-java"><span style="color: #51afef;">class</span> <span style="color: #ECBE7B;">ValidatorService</span> <span style="color: #51afef;">{</span>

    <span style="color: #51afef;">public</span> <span style="color: #ECBE7B;">boolean</span> <span style="color: #c678dd;">validateEmail</span><span style="color: #c678dd;">(</span><span style="color: #ECBE7B;">Customer</span> <span style="color: #dcaeea;">customer</span><span style="color: #c678dd;">)</span> <span style="color: #c678dd;">{</span>
        <span style="color: #ECBE7B;">var</span> <span style="color: #dcaeea;">email</span> = customer.getEmail<span style="color: #98be65;">()</span>;
        <span style="color: #51afef;">return</span> EMAIL_REGEX.matcher<span style="color: #98be65;">(</span>email<span style="color: #98be65;">)</span>.find<span style="color: #98be65;">()</span>;
    <span style="color: #c678dd;">}</span>
<span style="color: #51afef;">}</span>
</pre>
</div>

<div class="org-src-container">
<pre class="src src-java"><span style="color: #51afef;">class</span> <span style="color: #ECBE7B;">Customer</span> <span style="color: #51afef;">{</span>
    <span style="color: #51afef;">private</span> <span style="color: #ECBE7B;">String</span> <span style="color: #dcaeea;">firstName</span>;
    <span style="color: #51afef;">private</span> <span style="color: #ECBE7B;">String</span> <span style="color: #dcaeea;">lastName</span>;
    <span style="color: #51afef;">private</span> <span style="color: #ECBE7B;">LocalDate</span> <span style="color: #dcaeea;">birthDate</span>;
    <span style="color: #51afef;">private</span> <span style="color: #ECBE7B;">String</span> <span style="color: #dcaeea;">livingAddress</span>;
    <span style="color: #51afef;">private</span> <span style="color: #ECBE7B;">String</span> <span style="color: #dcaeea;">email</span>;
<span style="color: #51afef;">}</span>
</pre>
</div>

<div class="NOTES" id="org1b45433">
<p>
<b>Проблемы:</b>
</p>
<ul class="org-ul">
<li>Сложно переиспользовать. Нельзя переиспользовать функцию <code>validateEmail</code> там, где нет <code>Customer</code>.</li>
<li>Сложно тестировать. Необходимо заполнить всю структуру <code>Customer</code> для вызова.</li>
<li>Сложно читать. Невозможно предсказать поведение по сигнатуре метода.</li>
</ul>

<p>
В примере видно, что в функцию <code>validateEmail</code> передается вся структура <code>Customer</code>, хотя реально из нее используется только одно поле. Такой вид связанности несет сразу несколько проблем.
</p>

<p>
Страдает читабельность, без чтения кода только по сигнатуре функции невозможно понять, какие поля структуры в ней используются, почему туда передается объект целиком.
Функцию <code>validateEmail</code> сложно переиспользовать, так как при вызове необходимо передавать всю структуру <code>Customer</code> в качестве аргумента. По этой же причине ее сложно тестировать.
</p>

<p>
Иногда такой подход приводит к превращению класса <code>Customer</code> в свалку не связанных между собой данных, для того чтобы удовлетворить сразу несколько подобных методов.
</p>

<p>
Пример выше можно переписать следующем образом:
</p>

</div>

<div class="org-src-container">
<pre class="src src-java"><span style="color: #51afef;">class</span> <span style="color: #ECBE7B;">ValidatorService</span> <span style="color: #51afef;">{</span>

    <span style="color: #51afef;">public</span> <span style="color: #ECBE7B;">boolean</span> <span style="color: #c678dd;">validateEmail</span><span style="color: #c678dd;">(</span><span style="color: #ECBE7B;">String</span> <span style="color: #dcaeea;">email</span><span style="color: #c678dd;">)</span> <span style="color: #c678dd;">{</span>
        <span style="color: #51afef;">return</span> EMAIL_REGEX.matcher<span style="color: #98be65;">(</span>email<span style="color: #98be65;">)</span>.find<span style="color: #98be65;">()</span>;
    <span style="color: #c678dd;">}</span>
<span style="color: #51afef;">}</span>
</pre>
</div>
<div class="NOTES" id="org519b5c1">
<p>
Так мы переделали stamp coupling в data coupling.
</p>

</div>
</div>
</div>
<div id="outline-container-orgf8ef56e" class="outline-3">
<h3 id="orgf8ef56e">Data Coupling</h3>
<div class="outline-text-3" id="text-orgf8ef56e">
<p>
Возникает, когда модули обмениваются друг с другом данными через структуру, при этом используется каждое поле в этой структуре.
</p>
<div class="NOTES" id="org49b5152">
<p>
Этот вид связи возникает, когда один модуль передает данные в другой в виде параметров вызова функции. В отличие от stamp coupling передаются только необходимые данные. Если передается структура, то принимающий модуль должен использовать все ее поля.
Data Coupling считается слабой связью к которой следует стремиться.
</p>

</div>
</div>
</div>
<div id="outline-container-orge52e50d" class="outline-3">
<h3 id="orge52e50d">Message coupling</h3>
<div class="outline-text-3" id="text-orge52e50d">
<p>
Модули общаются только через передачу сообщений или вызовы методов без параметров.
</p>
<div class="NOTES" id="org524ba93">
<p>
Модули могут обмениваться сообщениями как внутри одного приложения, используя фреймворки вроде akka так и используя внешнее ПО вроде Kafka или RabbitMQ.
</p>

</div>
</div>
</div>
</div>

<div id="outline-container-org6678095" class="outline-2">
<h2 id="org6678095">Cohesion</h2>
<div class="outline-text-2" id="text-org6678095">
<div class="NOTES" id="org9f56376">
<p>
Сочетаемость (cohesion) — мера того, насколько функционально взаимосвязаны компоненты внутри модуля (сервиса, класса, функции). Насколько элементы внутри модуля нуждаются друг в друге.
Низкая сочетаемость внутри модуля означает, что он решает много не связанных друг с другом задач. Высокая сочетаемость означает, что весь код внутри модуля сфокусирован на решении одной конкретной задачи.
</p>

<p>
Почему это важно? Например, есть у вас задача добавить новый тип платежа. Вы открываете код и можете быстро найти место, куда нужно добавить новый код. Так как все что касается платежей у вас собрано в одном месте. При слабой сочетаемости вам придется по всей программе искать места, где нужно внести изменения.
</p>

<p>
Это чем-то похоже на принцип единства ответственности (SPR) из SOLID, сформулированный Робертом Мартином. Принцип гласит, что класс должен иметь только одну причину для изменения.
Считается, что в хорошо спроектированной программе присутствует сильная сочетаемость внутри модулей.
Рассмотрим некоторые виды сочетаемости в порядке от самых слабых к сильным.
</p>

</div>
</div>
<div id="outline-container-org296d206" class="outline-3">
<h3 id="org296d206">Coincidental cohesion</h3>
<div class="outline-text-3" id="text-org296d206">
<p>
Слабейший из видов сочетаемости. Когда элементы внутри модуля собраны по случайному принципу и никак друг с другом не связаны.
</p>
<div class="NOTES" id="org73910ef">
<p>
Часто возникает в классах или пакетах со словом utils в названии.
</p>

</div>
</div>
</div>
<div id="outline-container-org2aca2d7" class="outline-3">
<h3 id="org2aca2d7">Logical cohesion</h3>
<div class="outline-text-3" id="text-org2aca2d7">
<p>
Логическая сочетаемость возникает, когда части модуля логически делают похожие вещи, но никак друг с другом не связаны с точки зрения бизнес смысла.
</p>
<div class="NOTES" id="org02949a8">
<p>
До этого мы в качестве модулей рассматривали классы. Для иллюстрации логической сочетаемости давайте поднимемся на уровень пакетов. Например, как часто открывая новый проект мы видим такую схему проектов? Вы можете сказать что делает этот сервис?
</p>

</div>

<pre class="example" id="orgcf988f8">
  📁 dao
  📁 service
  📁 model
  ☕ Application.java
</pre>

<div class="NOTES" id="orgfc9c5f7">
<p>
Такая структура пакетов никак не подсказывает нам, что делает приложение. Теперь давайте заглянем внутрь пакетов и попробуем сгруппировать классы по функционалу, к которому они относятся, а не по названиям паттернов программирования.
</p>

</div>

<div class="LEFTCOL" id="orgb2ca1e3">
<pre class="example" id="org6498436">
  📁 dao
    ☕ OrderDao.java
    ☕ UserDao.java
    ☕ PostDao.java
  📁 service
    ☕ OrderService.java
    ☕ UserService.java
  📁 model
    ☕ User.java
    ☕ Order.java
    ☕ OrderItem.java
    ☕ OrderState.java
    ☕ Comment.java
    ☕ Post.java
  ☕ Application.java
</pre>

</div>

<div class="RIGHTCOL" id="org43ad871">
<pre class="example" id="org6946a3d">
  📁 orders
    ☕ Order.java
    ☕ OrderItem.java
    ☕ OrderState.java
    ☕ OrderDao.java
    ☕ OrderService.java
  📁 users
    ☕ User.java
    ☕ UserDao.java
    ☕ UserService.java
  📁 reviews
    ☕ Post.java
    ☕ Comment.java
    ☕ PostDao.java
  ☕ Application.java
</pre>

</div>

<div class="NOTES" id="org72b2a23">
<p>
Слева мы видим, что присутствует сильная связанность между пакетами (OrderService наверняка использует Order, OrderItem и OrderDao). И низкая сочетаемость внутри пакетов, между OrderDao и UserDao есть только логическая сочетаемость, оба класса реализуют доступ к БД, но при этом больше у них нет ничего общего. Функционально это разные области.
</p>

<p>
Деление классов на пакеты исходя из их функционального смысла лучше, так как такой код проще читать и поддерживать.
В 2011 году Роберт Мартин (Дядя Боб) ввел в обиход термин &ldquo;Кричащая Архитектура&rdquo;. Он утверждал, что сама архитектура приложения должна кричать о том какую функцию выполняет систем. Организация модулей слева же &ldquo;кричит&rdquo; только о паттернах, которые мы используем, но разве это так важно?
</p>

<p>
Конечно, в маленьком сервисе, состоящем из десятка классов все это не играет большой роли. Маленькие утилиты или небольшие сервисы вообще можно писать как угодно, пока весь их код свободно умещается в голове.
Попытки использовать в таких системах паттерны и подходы, призванные бороться со сложностью, наоборот приводят только к ее росту.
</p>

<p>
На уровне класса можно привести следующий пример логической сочетаемости, которую часто можно встретить в коде:
</p>

</div>

<div class="org-src-container">
<pre class="src src-java"><span style="color: #51afef;">public</span> <span style="color: #ECBE7B;">MessageSenderService</span> <span style="color: #51afef;">{</span>

    <span style="color: #51afef;">public</span> <span style="color: #ECBE7B;">void</span> <span style="color: #c678dd;">sendOrderProcessedEvent</span><span style="color: #c678dd;">()</span> <span style="color: #c678dd;">{</span> ... <span style="color: #c678dd;">}</span>
    <span style="color: #51afef;">public</span> <span style="color: #ECBE7B;">void</span> <span style="color: #c678dd;">sendReportMessage</span><span style="color: #c678dd;">()</span> <span style="color: #c678dd;">{</span> ... <span style="color: #c678dd;">}</span>
    <span style="color: #51afef;">public</span> <span style="color: #ECBE7B;">void</span> <span style="color: #c678dd;">sendEmailNotification</span><span style="color: #c678dd;">()</span> <span style="color: #c678dd;">{</span> ... <span style="color: #c678dd;">}</span>
<span style="color: #51afef;">}</span>
</pre>
</div>
<div class="NOTES" id="orgf29d08a">
<p>
Единственное, что связывает методы в этом классе, это то что все они отправляют сообщения в некую очередь и больше ничего. Почему именно это иногда становится причиной для объединения методов в один класс - сказать сложно. Особенно когда даже нет класса, который бы использовал больше одного из этих методов.
</p>

</div>
</div>
</div>

<div id="outline-container-org9acdcdb" class="outline-3">
<h3 id="org9acdcdb">Temporal cohesion</h3>
<div class="outline-text-3" id="text-org9acdcdb">
<p>
Элементы группируются в одном модуле, так как вызываются в одно время, но функционально никак друг с другом не связаны.
</p>
<div class="NOTES" id="orgbdd12d1">
<p>
Часто такой тип сочетаемости появляются у функций инициализации, собранных в одном классе. Например:
</p>

</div>

<div class="org-src-container">
<pre class="src src-java"><span style="color: #51afef;">public</span> <span style="color: #51afef;">interface</span> <span style="color: #ECBE7B;">ApplicationInitializer</span> <span style="color: #51afef;">{</span>
    <span style="color: #ECBE7B;">void</span> <span style="color: #c678dd;">initDatabase</span><span style="color: #c678dd;">()</span>;
    <span style="color: #ECBE7B;">void</span> <span style="color: #c678dd;">initPrinterService</span><span style="color: #c678dd;">()</span>;
    <span style="color: #ECBE7B;">void</span> <span style="color: #c678dd;">initFtpSerivce</span><span style="color: #c678dd;">()</span>;
<span style="color: #51afef;">}</span>
</pre>
</div>
<div class="NOTES" id="org7bdd4ea">
<p>
<b>Проблемы:</b>
</p>
<ul class="org-ul">
<li>Сложно переиспользовать. Функции друг с другом не связаны, зато сильно связаны с другими модулями.</li>
</ul>

<p>
Низкая сочетаемость этих методов друг с другом и сильная связанность с другими модулями приводит к проблемам с переиспользованием данного кода. Мы не можем использовать функции модуля FTP, если перед этим не подключили модуль <code>ApplicationInitializer</code> и не вызвали процедуру <code>initFtpSerivce()</code> из него.
В качестве возможного рефакторинга стоит вынести каждую функцию инициализации в соответствующий модуль и запускать ее при инициализации самого модуля.
</p>

</div>
</div>
</div>
<div id="outline-container-org1e74ca4" class="outline-3">
<h3 id="org1e74ca4">Procedural cohesion</h3>
<div class="outline-text-3" id="text-org1e74ca4">
<p>
Функции все еще слабо связаны друг с другом, но используются в одном месте, при этом порядок вызова функций имеет значение.
</p>

<div class="org-src-container">
<pre class="src src-java"><span style="color: #51afef;">public</span> <span style="color: #51afef;">class</span> <span style="color: #ECBE7B;">RegistrationService</span> <span style="color: #51afef;">{</span>

    <span style="color: #51afef;">public</span> <span style="color: #ECBE7B;">void</span> <span style="color: #c678dd;">registerUser</span><span style="color: #c678dd;">(</span><span style="color: #ECBE7B;">String</span> <span style="color: #dcaeea;">email</span><span style="color: #c678dd;">)</span> <span style="color: #c678dd;">{</span>
        validateEmail<span style="color: #98be65;">(</span>email<span style="color: #98be65;">)</span>;
        <span style="color: #ECBE7B;">User</span> <span style="color: #dcaeea;">user</span> = createNewUser<span style="color: #98be65;">(</span>email<span style="color: #98be65;">)</span>;
        loadProfileFromFacebook<span style="color: #98be65;">(</span>user<span style="color: #98be65;">)</span>;
        checkVipStatus<span style="color: #98be65;">(</span>user<span style="color: #98be65;">)</span>;
        sendGreetings<span style="color: #98be65;">(</span>email, user.getName<span style="color: #a9a1e1;">()</span><span style="color: #98be65;">)</span>;
    <span style="color: #c678dd;">}</span>
<span style="color: #51afef;">}</span>
</pre>
</div>

<div class="org-src-container">
<pre class="src src-java"><span style="color: #51afef;">public</span> <span style="color: #51afef;">interface</span> <span style="color: #ECBE7B;">UserService</span> <span style="color: #51afef;">{</span>
    <span style="color: #ECBE7B;">void</span> <span style="color: #c678dd;">validateEmail</span><span style="color: #c678dd;">(</span><span style="color: #ECBE7B;">String</span> <span style="color: #dcaeea;">email</span><span style="color: #c678dd;">)</span>;
    <span style="color: #ECBE7B;">User</span> <span style="color: #c678dd;">createNewUser</span><span style="color: #c678dd;">(</span><span style="color: #ECBE7B;">String</span> <span style="color: #dcaeea;">email</span><span style="color: #c678dd;">)</span>;
    <span style="color: #ECBE7B;">void</span> <span style="color: #c678dd;">loadProfileFromFacebook</span><span style="color: #c678dd;">(</span><span style="color: #ECBE7B;">User</span> <span style="color: #dcaeea;">user</span><span style="color: #c678dd;">)</span>;
    <span style="color: #ECBE7B;">void</span> <span style="color: #c678dd;">checkVipStatus</span><span style="color: #c678dd;">(</span><span style="color: #ECBE7B;">User</span> <span style="color: #dcaeea;">user</span><span style="color: #c678dd;">)</span>;
    <span style="color: #ECBE7B;">void</span> <span style="color: #c678dd;">sendGreetings</span><span style="color: #c678dd;">(</span><span style="color: #ECBE7B;">String</span> <span style="color: #dcaeea;">email</span>, <span style="color: #ECBE7B;">String</span> <span style="color: #dcaeea;">name</span><span style="color: #c678dd;">)</span>;
<span style="color: #51afef;">}</span>
</pre>
</div>
<div class="NOTES" id="orgcd95eeb">
<p>
<b>Проблемы:</b>
</p>
<ul class="org-ul">
<li>Сложно сопровождать. Необходимо полностью погрузиться в код каждой функции, чтобы ничего не сломать при изменении.</li>
</ul>

<p>
Последовательность вызовов процедур <code>UserService</code> этого класса должна сохраняться, мы же не хотим зарегистрировать пользователя с невалидным email или послать приветствие до того как получили его профиль на Фейсбуке. Узнать правильный порядок вызова этих процедур можно только полностью изучив код <code>UserService</code>. Из за этого пользоваться таким классом крайне неудобно, а код, который его использует, сложно поддается рефакторингу.
</p>

<p>
Глядя на код <code>registerUser</code> сложно сказать, каким должен быть объект <code>user</code> перед вызовом очередной процедуры, или что в нем поменяется после вызова. А изменение порядка вызова процедур может сломать весь алгоритм.
Поддержка такого кода требует от программиста полной концентрации и внимания, любое неосторожное движение приведет к возникновению ошибки.
К сожалению, такой код встречается крайне часто и обладает всеми недостатками процедурного программирования.
</p>

</div>


<div id="org15706bf" class="figure">
<p><img src="./img/proc-refactoring.png" alt="proc-refactoring.png" width="60%" />
</p>
</div>
<div class="NOTES" id="orgd8f157d">
<p>
Правильный подход, которого нужно придерживаться, &ldquo;делайте неправильные состояния невозможными&rdquo;. Если какие-то состояния в вашей программе не имеют смысла напишите код так, чтобы приложение никогда не могло попасть в это состояние. Давайте посмотрим, как мы можем переписать пример выше, чтобы сделать этот код более устойчивым к ошибкам. Следующие виды связанности считаются одинаково предпочтительными
</p>

</div>
</div>
</div>
<div id="outline-container-org5a9ebcc" class="outline-3">
<h3 id="org5a9ebcc">Sequential cohesion</h3>
<div class="outline-text-3" id="text-org5a9ebcc">
<p>
Сочетаемость по последовательности действий возникает в случае если результат работы одной части модуля является исходными данными для другой.
</p>
<div class="NOTES" id="org3a3daa9">
<p>
Пример sequential cohesion:
</p>

</div>

<div class="org-src-container">
<pre class="src src-java"><span style="color: #51afef;">public</span> <span style="color: #51afef;">class</span> <span style="color: #ECBE7B;">RegistrationService</span> <span style="color: #51afef;">{</span>

    <span style="color: #51afef;">public</span> <span style="color: #ECBE7B;">void</span> <span style="color: #c678dd;">registerUser</span><span style="color: #c678dd;">(</span><span style="color: #ECBE7B;">String</span> <span style="color: #dcaeea;">emailStr</span><span style="color: #c678dd;">)</span> <span style="color: #c678dd;">{</span>
        <span style="color: #ECBE7B;">Email</span> <span style="color: #dcaeea;">email</span> = validateEmail<span style="color: #98be65;">(</span>emailStr<span style="color: #98be65;">)</span>;
        <span style="color: #ECBE7B;">User</span> <span style="color: #dcaeea;">user</span> = createNewUser<span style="color: #98be65;">(</span>email<span style="color: #98be65;">)</span>;
        <span style="color: #ECBE7B;">UserProfile</span> <span style="color: #dcaeea;">profile</span> = loadProfileFromFacebook<span style="color: #98be65;">(</span>user<span style="color: #98be65;">)</span>;
        <span style="color: #ECBE7B;">VipStatus</span> <span style="color: #dcaeea;">vipStatus</span> = checkVipStatus<span style="color: #98be65;">(</span>user<span style="color: #98be65;">)</span>;
        sendGreetings<span style="color: #98be65;">(</span>profile, vipStatus<span style="color: #98be65;">)</span>;
    <span style="color: #c678dd;">}</span>
<span style="color: #51afef;">}</span>
</pre>
</div>

<div class="org-src-container">
<pre class="src src-java"><span style="color: #51afef;">public</span> <span style="color: #51afef;">interface</span> <span style="color: #ECBE7B;">UserService</span> <span style="color: #51afef;">{</span>
    <span style="color: #ECBE7B;">Email</span> <span style="color: #c678dd;">validateEmail</span><span style="color: #c678dd;">(</span><span style="color: #ECBE7B;">String</span> <span style="color: #dcaeea;">email</span><span style="color: #c678dd;">)</span>;
    <span style="color: #ECBE7B;">User</span> <span style="color: #c678dd;">createNewUser</span><span style="color: #c678dd;">(</span><span style="color: #ECBE7B;">Email</span> <span style="color: #dcaeea;">email</span><span style="color: #c678dd;">)</span>;
    <span style="color: #ECBE7B;">UserProfile</span> <span style="color: #c678dd;">loadProfileFromFacebook</span><span style="color: #c678dd;">(</span><span style="color: #ECBE7B;">User</span> <span style="color: #dcaeea;">user</span><span style="color: #c678dd;">)</span>;
    <span style="color: #ECBE7B;">VipStatus</span> <span style="color: #c678dd;">checkVipStatus</span><span style="color: #c678dd;">(</span><span style="color: #ECBE7B;">User</span> <span style="color: #dcaeea;">user</span><span style="color: #c678dd;">)</span>;
    <span style="color: #ECBE7B;">void</span> <span style="color: #c678dd;">sendGreetings</span><span style="color: #c678dd;">(</span><span style="color: #ECBE7B;">UserProfile</span> <span style="color: #dcaeea;">profile</span>, <span style="color: #ECBE7B;">VipStatus</span> <span style="color: #dcaeea;">vipStatus</span><span style="color: #c678dd;">)</span>;
<span style="color: #51afef;">}</span>
</pre>
</div>
<div class="NOTES" id="org146d98e">
<p>
В данном случае последовательность вызовов функций не имеет значения, так как благодаря системе типов мы просто не сможем, их вызывать в неправильном порядке.
</p>

</div>
</div>
</div>
<div id="outline-container-org8cc7751" class="outline-3">
<h3 id="org8cc7751">Communication cohesion</h3>
<div class="outline-text-3" id="text-org8cc7751">
<p>
Сочетаемость по взаимодействию возникает, когда группируется в один модуль все функции, которые работают с одними и теми же входными или выходными данными.
</p>
<div class="NOTES" id="orgf05100f">
<p>
Например:
</p>

</div>
<div class="org-src-container">
<pre class="src src-java"><span style="color: #51afef;">interface</span> <span style="color: #ECBE7B;">OrderService</span> <span style="color: #51afef;">{</span>
    <span style="color: #51afef;">public</span> <span style="color: #ECBE7B;">void</span> <span style="color: #c678dd;">addItem</span><span style="color: #c678dd;">(</span><span style="color: #ECBE7B;">Order</span> <span style="color: #dcaeea;">order</span>, <span style="color: #ECBE7B;">Item</span> <span style="color: #dcaeea;">item</span><span style="color: #c678dd;">)</span>;
    <span style="color: #51afef;">public</span> <span style="color: #ECBE7B;">void</span> <span style="color: #c678dd;">deleteAllItems</span><span style="color: #c678dd;">(</span><span style="color: #ECBE7B;">Order</span> <span style="color: #dcaeea;">order</span><span style="color: #c678dd;">)</span>;
    <span style="color: #51afef;">public</span> <span style="color: #ECBE7B;">Money</span> <span style="color: #c678dd;">calculateTotalSum</span><span style="color: #c678dd;">(</span><span style="color: #ECBE7B;">Order</span> <span style="color: #dcaeea;">order</span><span style="color: #c678dd;">)</span>;
    <span style="color: #51afef;">public</span> <span style="color: #ECBE7B;">void</span> <span style="color: #c678dd;">startDelivery</span><span style="color: #c678dd;">(</span><span style="color: #ECBE7B;">Order</span> <span style="color: #dcaeea;">order</span><span style="color: #c678dd;">)</span>;
<span style="color: #51afef;">}</span>
</pre>
</div>
<div class="NOTES" id="orgc5814bf">
<p>
Все методы принимают объект <code>Order</code>.
</p>

</div>

<div class="org-src-container">
<pre class="src src-java"><span style="color: #51afef;">interface</span> <span style="color: #ECBE7B;">ComputerFactory</span> <span style="color: #51afef;">{</span>
    <span style="color: #51afef;">public</span> <span style="color: #ECBE7B;">Computer</span> <span style="color: #c678dd;">newServer</span><span style="color: #c678dd;">(</span><span style="color: #ECBE7B;">Integer</span> <span style="color: #dcaeea;">ram</span>, <span style="color: #ECBE7B;">Integer</span> <span style="color: #dcaeea;">hdd</span>, <span style="color: #ECBE7B;">Integer</span> <span style="color: #dcaeea;">cpu</span><span style="color: #c678dd;">)</span>;
    <span style="color: #51afef;">public</span> <span style="color: #ECBE7B;">Computer</span> <span style="color: #c678dd;">newPc</span><span style="color: #c678dd;">(</span><span style="color: #ECBE7B;">Monitor</span> <span style="color: #dcaeea;">monitor</span>, <span style="color: #ECBE7B;">Mouse</span> <span style="color: #dcaeea;">mouse</span>, <span style="color: #ECBE7B;">SystemUnit</span> <span style="color: #dcaeea;">unit</span><span style="color: #c678dd;">)</span>;
    <span style="color: #51afef;">public</span> <span style="color: #ECBE7B;">Computer</span> <span style="color: #c678dd;">newNotebook</span><span style="color: #c678dd;">(</span><span style="color: #ECBE7B;">Model</span> <span style="color: #dcaeea;">model</span><span style="color: #c678dd;">)</span>;
<span style="color: #51afef;">}</span>
</pre>
</div>
<div class="NOTES" id="org593dfa5">
<p>
Все методы возвращают объект <code>Computer</code>.
</p>

<p>
Подобные классы сосредоточены на операциях, которые можно произвести над сущностью или на разных способах как получить сущность. Их достаточно легко переиспользовать целиком в разных частях программы. Также примером сочетаемости по взаимодействию можно считать классы в ООП, так как они по определению представляют из себя набор данных и функций, которые с ними работают.
</p>

</div>
<div class="org-src-container">
<pre class="src src-java"><span style="color: #51afef;">class</span> <span style="color: #ECBE7B;">User</span> <span style="color: #51afef;">{</span>
    <span style="color: #51afef;">private</span> <span style="color: #ECBE7B;">Long</span> <span style="color: #dcaeea;">id</span>;
    <span style="color: #51afef;">private</span> <span style="color: #ECBE7B;">Image</span> <span style="color: #dcaeea;">avatar</span>;
    <span style="color: #51afef;">private</span> <span style="color: #ECBE7B;">String</span> <span style="color: #dcaeea;">email</span>;
    <span style="color: #51afef;">private</span> <span style="color: #ECBE7B;">List</span><span style="color: #c678dd;">&lt;</span><span style="color: #ECBE7B;">Orders</span><span style="color: #c678dd;">&gt;</span> <span style="color: #dcaeea;">orders</span>;
    <span style="color: #51afef;">private</span> <span style="color: #ECBE7B;">List</span><span style="color: #c678dd;">&lt;</span><span style="color: #ECBE7B;">Review</span><span style="color: #c678dd;">&gt;</span> <span style="color: #dcaeea;">reviews</span>;

    <span style="color: #51afef;">public</span> <span style="color: #ECBE7B;">void</span> <span style="color: #c678dd;">changeAvatar</span><span style="color: #c678dd;">(</span><span style="color: #ECBE7B;">Image</span> <span style="color: #dcaeea;">image</span><span style="color: #c678dd;">)</span> <span style="color: #c678dd;">{</span> ... <span style="color: #c678dd;">}</span>
    <span style="color: #51afef;">public</span> <span style="color: #ECBE7B;">void</span> <span style="color: #c678dd;">resetPassword</span><span style="color: #c678dd;">()</span> <span style="color: #c678dd;">{</span> ... <span style="color: #c678dd;">}</span>
    <span style="color: #51afef;">public</span> <span style="color: #ECBE7B;">void</span> <span style="color: #c678dd;">placeNewOrder</span><span style="color: #c678dd;">(</span><span style="color: #ECBE7B;">Order</span> <span style="color: #dcaeea;">order</span><span style="color: #c678dd;">)</span> <span style="color: #c678dd;">{</span> ... <span style="color: #c678dd;">}</span>
    <span style="color: #51afef;">public</span> <span style="color: #ECBE7B;">void</span> <span style="color: #c678dd;">postReview</span><span style="color: #c678dd;">(</span><span style="color: #ECBE7B;">Review</span> <span style="color: #dcaeea;">review</span><span style="color: #c678dd;">)</span> <span style="color: #c678dd;">{</span> ... <span style="color: #c678dd;">}</span>
    <span style="color: #51afef;">public</span> <span style="color: #ECBE7B;">void</span> <span style="color: #c678dd;">assignVipStatus</span><span style="color: #c678dd;">()</span> <span style="color: #c678dd;">{</span> ... <span style="color: #c678dd;">}</span>
<span style="color: #51afef;">}</span>
</pre>
</div>
<div class="NOTES" id="orgdded2cd">
<p>
Заметьте, что в приведенном примере у класса нет ни сеттеров, ни геттеров на каждое поле, их вообще в принципе не должно быть в ООП коде. Сеттеры подразумевают, что существует какой-то внешний, по отношению к классу код, который принимает решения на счет данных внутри этого класса, а это является нарушением принципа инкапсуляции.
Несмотря на то, что все функции в классе <code>User</code> работают с одними и теми же данными, все же функционально их можно поделить на несколько областей: управление профилем пользователя, заказами и отзывами. Если в программе эти три области разделены на отдельные модули и имеют четкие границы, то не нужно боятся в каждом модуле сделать свой класс <code>User</code> с релевантным набором функций и данных, объединенных между собой только общим идентификатором.
Не смотря на то, что физически пользователь один, в разных контекстах нас могут интересовать разные его стороны. Не делая такое разделение мы увеличиваем связанность между модулями, которые используют общий класс <code>User</code>. При этом сам класс <code>User</code> становится сложным для понимания и тестирования из за своих размеров.
</p>

</div>

<div id="org58c7a42" class="figure">
<p><img src="./img/oop-at-home.png" alt="oop-at-home.png" />
</p>
</div>
</div>
</div>

<div id="outline-container-orgc656562" class="outline-3">
<h3 id="orgc656562">Functional cohesion</h3>
<div class="outline-text-3" id="text-orgc656562">
<p>
Возникает, когда элементы модуля сгруппированы вместе, так как все они вносят вклад в выполнение одной и той же функции.
</p>
<div class="NOTES" id="org851beec">
<p>
Давайте рассмотрим как мы можем поделить <code>OrderService</code> согласно функциям, которые он реализует.
Например, мы можем его поделить на класс, управляющий корзиной, калькулятор и класс отвечающий за доставку.
</p>

</div>

<div class="org-src-container">
<pre class="src src-java"><span style="color: #51afef;">interface</span> <span style="color: #ECBE7B;">OrderService</span> <span style="color: #51afef;">{</span>
    <span style="color: #51afef;">public</span> <span style="color: #ECBE7B;">void</span> <span style="color: #c678dd;">addItem</span><span style="color: #c678dd;">(</span><span style="color: #ECBE7B;">Order</span> <span style="color: #dcaeea;">order</span>, <span style="color: #ECBE7B;">Item</span> <span style="color: #dcaeea;">item</span><span style="color: #c678dd;">)</span>;
    <span style="color: #51afef;">public</span> <span style="color: #ECBE7B;">void</span> <span style="color: #c678dd;">deleteAllItems</span><span style="color: #c678dd;">(</span><span style="color: #ECBE7B;">Order</span> <span style="color: #dcaeea;">order</span><span style="color: #c678dd;">)</span>;
    <span style="color: #51afef;">public</span> <span style="color: #ECBE7B;">Money</span> <span style="color: #c678dd;">calculateTotalSum</span><span style="color: #c678dd;">(</span><span style="color: #ECBE7B;">Order</span> <span style="color: #dcaeea;">order</span><span style="color: #c678dd;">)</span>;
    <span style="color: #51afef;">public</span> <span style="color: #ECBE7B;">void</span> <span style="color: #c678dd;">startDelivery</span><span style="color: #c678dd;">(</span><span style="color: #ECBE7B;">Order</span> <span style="color: #dcaeea;">order</span><span style="color: #c678dd;">)</span>;
<span style="color: #51afef;">}</span>
</pre>
</div>

<div class="org-src-container">
<pre class="src src-java"><span style="color: #51afef;">interface</span> <span style="color: #ECBE7B;">OrderCart</span> <span style="color: #51afef;">{</span>
    <span style="color: #51afef;">public</span> <span style="color: #ECBE7B;">void</span> <span style="color: #c678dd;">addItem</span><span style="color: #c678dd;">(</span><span style="color: #ECBE7B;">Order</span> <span style="color: #dcaeea;">order</span>, <span style="color: #ECBE7B;">Item</span> <span style="color: #dcaeea;">item</span><span style="color: #c678dd;">)</span>;
    <span style="color: #51afef;">public</span> <span style="color: #ECBE7B;">void</span> <span style="color: #c678dd;">deleteAllItems</span><span style="color: #c678dd;">(</span><span style="color: #ECBE7B;">Order</span> <span style="color: #dcaeea;">order</span><span style="color: #c678dd;">)</span>;
<span style="color: #51afef;">}</span>

<span style="color: #51afef;">interface</span> <span style="color: #ECBE7B;">OrderCostCalculator</span> <span style="color: #51afef;">{</span>
    <span style="color: #51afef;">public</span> <span style="color: #ECBE7B;">Money</span> <span style="color: #c678dd;">calculateTotalSum</span><span style="color: #c678dd;">(</span><span style="color: #ECBE7B;">Order</span> <span style="color: #dcaeea;">order</span><span style="color: #c678dd;">)</span>;
<span style="color: #51afef;">}</span>

<span style="color: #51afef;">interface</span> <span style="color: #ECBE7B;">OrderDelivery</span> <span style="color: #51afef;">{</span>
    <span style="color: #51afef;">public</span> <span style="color: #ECBE7B;">void</span> <span style="color: #c678dd;">startDelivery</span><span style="color: #c678dd;">(</span><span style="color: #ECBE7B;">Order</span> <span style="color: #dcaeea;">order</span><span style="color: #c678dd;">)</span>;
<span style="color: #51afef;">}</span>
</pre>
</div>
<div class="NOTES" id="orgc9809ba">
<p>
Обратите внимание, за счет этого разделения по функциональности имена наших классов стали более конкретными. И сами классы теперь сфокусированы на исполнение ровно одной функции.
Надо заметить, что такое разделение имеет смысл только если каждый из новых классов используется отдельными потребителем. Иначе, если потребитель <code>OrderService</code> был только один, таким разделением мы только увеличим количество связей в системе.
</p>

</div>
</div>
</div>
</div>
<div id="outline-container-orgda03905" class="outline-2">
<h2 id="orgda03905">Low coupling &amp; High cohesion</h2>
<div class="outline-text-2" id="text-orgda03905">
<p>
Модули, которые следуют принципам слабой связанности и высокой сочетаемости, обладают следующими свойствами:
</p>
<ul class="org-ul">
<li>Изменения в одном модуле не влияют на остальные модули</li>
<li>Проще разбираться в коде модуля, без необходимости изучать остальные модули</li>
<li>Удобство в переиспользовании</li>
</ul>
<div class="NOTES" id="orgabfcec5">
<p>
Coupling влияет на то, насколько просто нам поменять код, когда нам это нужно. Сколько мест нам нужно поменять и как будут эти изменения распространяться на остальную систему.
Сильно связанные модули не обладают гибкость, их сложно переиспользовать в других местах и как следствие плохо поддаются тестированию.
При изменении одного класса в сильно связанной программе часто необходимо внести изменения и в другие. В небольшой программе это не страшно, часто мы легко можем понять, что затронут наши изменения, шанс допустить ошибку невелик. Но с ростом приложения эти неявные взаимосвязи не всегда известны всем разработчикам и вероятность ошибки сильно возрастает.
</p>

<p>
Cohesion влияет на то, как быстро мы можем понять где нам нужно поменять код. Как только находим одно место, которое необходимо поменять есть высокая вероятность, что рядом будут и остальные места, которые нужно изменить.
Низкая сочетаемость означает, что код, который реализуют какую-то функцию или бизнес процесс в приложении размазан по всей кодовой базе. Из за этого тяжело понять, какой код относится к конкретному функционалу и приходится постоянно переключаться между модулями, для того чтобы построить в голове общую картину.
</p>

<p>
Чтобы определить, на сколько ваш код соответствует принципам низкой связанности и высокой сочетаемости можно задать себе вопросы из книги Программист прагматик. Когда вы сталкиваетесь с проблемой, оцените, насколько локален процесс ее устранения. Нужно изменить лишь один модуль, или изменения должны происходить по всей системе? Когда вы меняете что-либо, устраняются ли при этом все ошибки или происходит загадочное появление новых?
</p>

<p>
Часто, когда разработчик пытается реализовать рекомендации по низкому coupling, высокому cohesion, он прикладывает слишком много усилий к реализации первой рекомендации (низкий coupling) и полностью забывает о другой. Это приводит к ситуации, когда код действительно разделен (decoupled), но в то же время не имеет четкой направленности. Его части настолько отделены друг от друга, что становится трудно или даже невозможно понять их назначение. Эта ситуация называется деструктивной развязкой (destructive decoupling).
</p>

<p>
Coupling и Cohision всегда упоминают в паре, и это не случайно. На практике это две силы, которые противоречат друг другу. То есть, чтобы создать максимально слабосвязанную систему можно просто поместить весь код в один файл. Нет модулей - нет связей между ними - нет проблем. Но при этом такой код будет обладать слабой сочетаемостью, так как код внутри файла будет решать функционально разные проблемы.
С другой стороны, чтобы добиться максимального Cohesion нужно выделить каждую функцию в отдельный класс. Но в такой системе будет очень сильный Coupling между такими классами.
</p>

<p>
Собственно задача программиста при написании кода соблюдать баланс между этими двумя понятиями - связанность и сочетаемость.
</p>

</div>

<blockquote>
<p>
Design is About Balancing Cohesion and Coupling (not blindly following principles) &#x2013; Copeland
</p>
</blockquote>
</div>
</div>
</div>
</body>
</html>
